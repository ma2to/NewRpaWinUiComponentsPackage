using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.UI.Xaml;
using Microsoft.UI.Xaml.Controls;
using Windows.Graphics.Display;

namespace RpaWinUiComponentsPackage.AdvancedWinUiDataGrid;

/// <summary>
/// PUBLIC API: Auto row height configuration
/// ENTERPRISE: Professional text layout and sizing
/// </summary>
public sealed record AutoRowHeightConfiguration
{
    /// <summary>Enable auto row height for multiline text</summary>
    public bool IsEnabled { get; init; } = true;

    /// <summary>Minimum row height in pixels</summary>
    public double MinimumRowHeight { get; init; } = 32;

    /// <summary>Maximum row height in pixels (0 = unlimited)</summary>
    public double MaximumRowHeight { get; init; } = 200;

    /// <summary>Padding inside cells for text layout</summary>
    public Thickness CellPadding { get; init; } = new(8, 4, 8, 4);

    /// <summary>Text wrapping mode for multiline text</summary>
    public TextWrapping TextWrapping { get; init; } = TextWrapping.Wrap;

    /// <summary>Enable text trimming when content exceeds max height</summary>
    public bool EnableTextTrimming { get; init; } = true;

    /// <summary>Text trimming mode</summary>
    public TextTrimming TextTrimming { get; init; } = TextTrimming.WordEllipsis;

    /// <summary>Font size for text measurement</summary>
    public double FontSize { get; init; } = 14;

    /// <summary>Font family for text measurement</summary>
    public string FontFamily { get; init; } = "Segoe UI";

    /// <summary>Line height multiplier (1.0 = normal, 1.2 = 120% spacing)</summary>
    public double LineHeight { get; init; } = 1.2;

    /// <summary>Debounce interval for height recalculation during typing</summary>
    public TimeSpan RecalculationDebounce { get; init; } = TimeSpan.FromMilliseconds(300);

    /// <summary>Enable performance optimization for large datasets</summary>
    public bool UseVirtualizedMeasurement { get; init; } = true;

    /// <summary>Cache measurement results for better performance</summary>
    public bool EnableMeasurementCache { get; init; } = true;

    /// <summary>Create default configuration</summary>
    public static AutoRowHeightConfiguration Default => new();

    /// <summary>Create compact configuration with smaller heights</summary>
    public static AutoRowHeightConfiguration Compact => new()
    {
        MinimumRowHeight = 24,
        MaximumRowHeight = 120,
        CellPadding = new(6, 2, 6, 2),
        FontSize = 12,
        LineHeight = 1.1
    };

    /// <summary>Create spacious configuration with larger heights</summary>
    public static AutoRowHeightConfiguration Spacious => new()
    {
        MinimumRowHeight = 40,
        MaximumRowHeight = 300,
        CellPadding = new(12, 8, 12, 8),
        FontSize = 16,
        LineHeight = 1.4
    };
}

/// <summary>
/// PUBLIC API: Text measurement result
/// </summary>
public sealed record TextMeasurementResult
{
    public double Width { get; init; }
    public double Height { get; init; }
    public int LineCount { get; init; }
    public bool IsTruncated { get; init; }
    public string? TruncatedText { get; init; }

    public static TextMeasurementResult Create(double width, double height, int lineCount, bool isTruncated = false, string? truncatedText = null) =>
        new()
        {
            Width = width,
            Height = height,
            LineCount = lineCount,
            IsTruncated = isTruncated,
            TruncatedText = truncatedText
        };
}

/// <summary>
/// PUBLIC API: Row height calculation result
/// </summary>
public sealed record RowHeightCalculationResult
{
    public int RowIndex { get; init; }
    public double CalculatedHeight { get; init; }
    public double ActualHeight { get; init; }
    public IReadOnlyDictionary<string, TextMeasurementResult> ColumnMeasurements { get; init; } = new Dictionary<string, TextMeasurementResult>();
    public TimeSpan CalculationTime { get; init; }
    public bool FromCache { get; init; }

    public static RowHeightCalculationResult Create(int rowIndex, double height, IReadOnlyDictionary<string, TextMeasurementResult>? columnMeasurements = null, TimeSpan calculationTime = default, bool fromCache = false) =>
        new()
        {
            RowIndex = rowIndex,
            CalculatedHeight = height,
            ActualHeight = height,
            ColumnMeasurements = columnMeasurements ?? new Dictionary<string, TextMeasurementResult>(),
            CalculationTime = calculationTime,
            FromCache = fromCache
        };
}

/// <summary>
/// INTERNAL: Auto row height calculation engine
/// PERFORMANCE: Optimized text measurement with caching and virtualization
/// </summary>
internal sealed class AutoRowHeightEngine : IDisposable
{
    private readonly ILogger _logger;
    private readonly Dictionary<string, TextMeasurementResult> _measurementCache = new();
    private readonly Dictionary<int, RowHeightCalculationResult> _rowHeightCache = new();
    private AutoRowHeightConfiguration _configuration;
    private TextBlock? _measurementTextBlock;
    private bool _disposed;

    public AutoRowHeightEngine(ILogger logger, AutoRowHeightConfiguration? configuration = null)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _configuration = configuration ?? AutoRowHeightConfiguration.Default;

        InitializeMeasurementTextBlock();
        _logger.LogInformation("AUTO_HEIGHT: Engine initialized with min={MinHeight}, max={MaxHeight}",
            _configuration.MinimumRowHeight, _configuration.MaximumRowHeight);
    }

    /// <summary>
    /// ENTERPRISE: Calculate optimal row height for multiline text content
    /// PERFORMANCE: Cached measurement with text layout optimization
    /// </summary>
    public async Task<RowHeightCalculationResult> CalculateRowHeightAsync(
        int rowIndex,
        IReadOnlyDictionary<string, object?> rowData,
        IReadOnlyDictionary<string, double> columnWidths)
    {
        try
        {
            var startTime = DateTime.UtcNow;

            // Check cache first
            if (_configuration.EnableMeasurementCache && _rowHeightCache.TryGetValue(rowIndex, out var cachedResult))
            {
                _logger.LogTrace("AUTO_HEIGHT: Using cached height for row {RowIndex}: {Height}px", rowIndex, cachedResult.CalculatedHeight);
                return cachedResult;
            }

            var columnMeasurements = new Dictionary<string, TextMeasurementResult>();
            double maxHeight = _configuration.MinimumRowHeight;

            // Measure each column's text content
            foreach (var kvp in rowData)
            {
                var columnName = kvp.Key;
                var cellValue = kvp.Value?.ToString() ?? "";

                if (!columnWidths.TryGetValue(columnName, out var columnWidth))
                {
                    columnWidth = 150; // Default width
                }

                var measurement = await MeasureTextAsync(cellValue, columnWidth);
                columnMeasurements[columnName] = measurement;

                // Take the maximum height from all columns
                var cellHeight = Math.Max(measurement.Height + _configuration.CellPadding.Top + _configuration.CellPadding.Bottom, _configuration.MinimumRowHeight);
                maxHeight = Math.Max(maxHeight, cellHeight);
            }

            // Apply maximum height limit
            if (_configuration.MaximumRowHeight > 0)
            {
                maxHeight = Math.Min(maxHeight, _configuration.MaximumRowHeight);
            }

            var calculationTime = DateTime.UtcNow - startTime;
            var result = RowHeightCalculationResult.Create(rowIndex, maxHeight, columnMeasurements, calculationTime);

            // Cache the result
            if (_configuration.EnableMeasurementCache)
            {
                _rowHeightCache[rowIndex] = result;
            }

            _logger.LogTrace("AUTO_HEIGHT: Calculated height for row {RowIndex}: {Height}px in {Time}ms",
                rowIndex, maxHeight, calculationTime.TotalMilliseconds);

            return result;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "AUTO_HEIGHT: Error calculating row height for row {RowIndex}", rowIndex);
            return RowHeightCalculationResult.Create(rowIndex, _configuration.MinimumRowHeight);
        }
    }

    /// <summary>
    /// ENTERPRISE: Batch calculate row heights for multiple rows
    /// PERFORMANCE: Optimized batch processing with progress reporting
    /// </summary>
    public async Task<IReadOnlyList<RowHeightCalculationResult>> CalculateBatchRowHeightsAsync(
        IReadOnlyList<(int index, IReadOnlyDictionary<string, object?> data)> rows,
        IReadOnlyDictionary<string, double> columnWidths,
        IProgress<BatchCalculationProgress>? progress = null)
    {
        try
        {
            _logger.LogInformation("AUTO_HEIGHT: Starting batch calculation for {RowCount} rows", rows.Count);

            var results = new List<RowHeightCalculationResult>();
            var startTime = DateTime.UtcNow;

            for (int i = 0; i < rows.Count; i++)
            {
                var (rowIndex, rowData) = rows[i];
                var result = await CalculateRowHeightAsync(rowIndex, rowData, columnWidths);
                results.Add(result);

                // Report progress
                if (progress != null && i % 10 == 0) // Report every 10 rows
                {
                    var elapsed = DateTime.UtcNow - startTime;
                    var progressInfo = new BatchCalculationProgress
                    {
                        ProcessedRows = i + 1,
                        TotalRows = rows.Count,
                        ElapsedTime = elapsed,
                        EstimatedTimeRemaining = TimeSpan.FromMilliseconds(elapsed.TotalMilliseconds / (i + 1) * (rows.Count - i - 1))
                    };
                    progress.Report(progressInfo);
                }
            }

            var totalTime = DateTime.UtcNow - startTime;
            _logger.LogInformation("AUTO_HEIGHT: Batch calculation completed for {RowCount} rows in {Time}ms",
                rows.Count, totalTime.TotalMilliseconds);

            return results;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "AUTO_HEIGHT: Error during batch row height calculation");
            return Array.Empty<RowHeightCalculationResult>();
        }
    }

    /// <summary>
    /// ENTERPRISE: Measure text content for optimal layout
    /// PERFORMANCE: Cached measurement with font and layout optimization
    /// </summary>
    public async Task<TextMeasurementResult> MeasureTextAsync(string text, double availableWidth)
    {
        try
        {
            if (string.IsNullOrEmpty(text))
            {
                return TextMeasurementResult.Create(0, _configuration.MinimumRowHeight, 1);
            }

            // Check cache first
            var cacheKey = $"{text}_{availableWidth}_{_configuration.FontSize}_{_configuration.FontFamily}";
            if (_configuration.EnableMeasurementCache && _measurementCache.TryGetValue(cacheKey, out var cachedMeasurement))
            {
                return cachedMeasurement;
            }

            await EnsureMeasurementTextBlockAsync();

            if (_measurementTextBlock == null)
            {
                _logger.LogWarning("AUTO_HEIGHT: Measurement TextBlock not available, using default height");
                return TextMeasurementResult.Create(availableWidth, _configuration.MinimumRowHeight, 1);
            }

            // Configure the measurement TextBlock
            _measurementTextBlock.Text = text;
            _measurementTextBlock.Width = availableWidth - _configuration.CellPadding.Left - _configuration.CellPadding.Right;
            _measurementTextBlock.TextWrapping = _configuration.TextWrapping;
            _measurementTextBlock.FontSize = _configuration.FontSize;
            _measurementTextBlock.FontFamily = new Microsoft.UI.Xaml.Media.FontFamily(_configuration.FontFamily);

            if (_configuration.EnableTextTrimming && _configuration.MaximumRowHeight > 0)
            {
                _measurementTextBlock.TextTrimming = _configuration.TextTrimming;
                _measurementTextBlock.MaxHeight = _configuration.MaximumRowHeight - _configuration.CellPadding.Top - _configuration.CellPadding.Bottom;
            }

            // Force layout update
            _measurementTextBlock.Measure(new Windows.Foundation.Size(double.PositiveInfinity, double.PositiveInfinity));

            var measuredWidth = _measurementTextBlock.DesiredSize.Width;
            var measuredHeight = _measurementTextBlock.DesiredSize.Height;

            // Calculate line count based on line height
            var lineHeight = _configuration.FontSize * _configuration.LineHeight;
            var lineCount = (int)Math.Ceiling(measuredHeight / lineHeight);

            // Check if text was truncated
            var isTruncated = _configuration.EnableTextTrimming &&
                             _configuration.MaximumRowHeight > 0 &&
                             measuredHeight >= (_configuration.MaximumRowHeight - _configuration.CellPadding.Top - _configuration.CellPadding.Bottom);

            var result = TextMeasurementResult.Create(measuredWidth, measuredHeight, lineCount, isTruncated);

            // Cache the result
            if (_configuration.EnableMeasurementCache)
            {
                _measurementCache[cacheKey] = result;
            }

            return result;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "AUTO_HEIGHT: Error measuring text: {Text}", text.Substring(0, Math.Min(50, text.Length)));
            return TextMeasurementResult.Create(availableWidth, _configuration.MinimumRowHeight, 1);
        }
    }

    /// <summary>
    /// CONFIGURATION: Update auto row height configuration
    /// </summary>
    public void UpdateConfiguration(AutoRowHeightConfiguration configuration)
    {
        _configuration = configuration ?? throw new ArgumentNullException(nameof(configuration));

        // Clear caches when configuration changes
        _measurementCache.Clear();
        _rowHeightCache.Clear();

        _logger.LogInformation("AUTO_HEIGHT: Configuration updated, caches cleared");
    }

    /// <summary>
    /// CACHE: Clear measurement caches to free memory
    /// </summary>
    public void ClearCaches()
    {
        _measurementCache.Clear();
        _rowHeightCache.Clear();

        _logger.LogInformation("AUTO_HEIGHT: Measurement caches cleared");
    }

    /// <summary>
    /// CACHE: Clear cache for specific row
    /// </summary>
    public void InvalidateRowCache(int rowIndex)
    {
        _rowHeightCache.Remove(rowIndex);
        _logger.LogTrace("AUTO_HEIGHT: Invalidated cache for row {RowIndex}", rowIndex);
    }

    private void InitializeMeasurementTextBlock()
    {
        try
        {
            // This will be initialized properly when UI context is available
            _measurementTextBlock = new TextBlock
            {
                Visibility = Visibility.Collapsed,
                TextWrapping = _configuration.TextWrapping,
                FontSize = _configuration.FontSize
            };

            _logger.LogTrace("AUTO_HEIGHT: Measurement TextBlock initialized");
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "AUTO_HEIGHT: Failed to initialize measurement TextBlock, will retry later");
        }
    }

    private async Task EnsureMeasurementTextBlockAsync()
    {
        if (_measurementTextBlock == null)
        {
            await Task.Run(() =>
            {
                InitializeMeasurementTextBlock();
            });
        }
    }

    public void Dispose()
    {
        if (_disposed) return;

        _measurementCache.Clear();
        _rowHeightCache.Clear();
        _measurementTextBlock = null;

        _logger.LogInformation("AUTO_HEIGHT: Engine disposed");
        _disposed = true;
    }
}

/// <summary>
/// PUBLIC API: Progress reporting for batch row height calculations
/// </summary>
public sealed record BatchCalculationProgress
{
    public int ProcessedRows { get; init; }
    public int TotalRows { get; init; }
    public double CompletionPercentage => TotalRows > 0 ? (double)ProcessedRows / TotalRows * 100 : 0;
    public TimeSpan ElapsedTime { get; init; }
    public TimeSpan? EstimatedTimeRemaining { get; init; }

    public static BatchCalculationProgress Create(int processed, int total, TimeSpan elapsed) =>
        new()
        {
            ProcessedRows = processed,
            TotalRows = total,
            ElapsedTime = elapsed
        };
}
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using System.Text.RegularExpressions;

namespace RpaWinUiComponentsPackage.AdvancedWinUiDataGrid;

/// <summary>
/// PUBLIC API: Search and Filter functionality
/// ENTERPRISE: Advanced search with regex support and complex filter combinations
/// </summary>
public enum FilterOperator
{
    // Basic comparison operators
    Equals,
    NotEquals,
    GreaterThan,
    GreaterThanOrEqual,
    LessThan,
    LessThanOrEqual,

    // String operators
    Contains,
    NotContains,
    StartsWith,
    EndsWith,

    // Null checking
    IsNull,
    IsNotNull,
    IsEmpty,
    IsNotEmpty,

    // Collection operators
    In,
    NotIn,
    Between,
    NotBetween,

    // Advanced operators
    Regex,
    Custom,

    // Logical operators for grouping
    And,
    Or,
    Not
}

/// <summary>
/// PUBLIC API: Logic operators for complex filter combinations
/// </summary>
public enum FilterLogicOperator
{
    And,
    Or
}

/// <summary>
/// PUBLIC API: Search scope options
/// </summary>
public enum SearchScope
{
    /// <summary>Search all data including non-visible rows</summary>
    AllData,
    /// <summary>Search only visible/filtered data</summary>
    VisibleData,
    /// <summary>Search only selected data</summary>
    SelectedData
}

/// <summary>
/// PUBLIC API: Filter definition for complex filtering
/// ENTERPRISE: Supports business logic filter combinations like (A AND B) OR (C AND D)
/// </summary>
public sealed record FilterDefinition
{
    public string? ColumnName { get; init; }
    public FilterOperator Operator { get; init; }
    public object? Value { get; init; }
    public object? SecondValue { get; init; } // For Between operations
    public FilterLogicOperator LogicOperator { get; init; } = FilterLogicOperator.And;
    public bool GroupStart { get; init; }
    public bool GroupEnd { get; init; }
    public string? FilterName { get; init; }
    public IReadOnlyList<FilterDefinition>? ChildFilters { get; init; }

    // Static factory methods for easier creation
    public static FilterDefinition Equals(string columnName, object value) =>
        new() { ColumnName = columnName, Operator = FilterOperator.Equals, Value = value };

    public static FilterDefinition NotEquals(string columnName, object value) =>
        new() { ColumnName = columnName, Operator = FilterOperator.NotEquals, Value = value };

    public static FilterDefinition Contains(string columnName, string value) =>
        new() { ColumnName = columnName, Operator = FilterOperator.Contains, Value = value };

    public static FilterDefinition GreaterThan(string columnName, object value) =>
        new() { ColumnName = columnName, Operator = FilterOperator.GreaterThan, Value = value };

    public static FilterDefinition LessThan(string columnName, object value) =>
        new() { ColumnName = columnName, Operator = FilterOperator.LessThan, Value = value };

    public static FilterDefinition Between(string columnName, object fromValue, object toValue) =>
        new() { ColumnName = columnName, Operator = FilterOperator.Between, Value = fromValue, SecondValue = toValue };

    public static FilterDefinition Regex(string columnName, string pattern) =>
        new() { ColumnName = columnName, Operator = FilterOperator.Regex, Value = pattern };

    public static FilterDefinition IsNull(string columnName) =>
        new() { ColumnName = columnName, Operator = FilterOperator.IsNull };

    public static FilterDefinition IsNotNull(string columnName) =>
        new() { ColumnName = columnName, Operator = FilterOperator.IsNotNull };

    // Complex filter creation
    public static FilterDefinition And(params FilterDefinition[] filters) =>
        new() { LogicOperator = FilterLogicOperator.And, ChildFilters = filters };

    public static FilterDefinition Or(params FilterDefinition[] filters) =>
        new() { LogicOperator = FilterLogicOperator.Or, ChildFilters = filters };
}

/// <summary>
/// PUBLIC API: Advanced search criteria with regex support
/// </summary>
public sealed record AdvancedSearchCriteria
{
    public string SearchText { get; init; } = string.Empty;
    public string[]? TargetColumns { get; init; }
    public bool UseRegex { get; init; }
    public bool CaseSensitive { get; init; }
    public SearchScope Scope { get; init; } = SearchScope.AllData;
    public int? MaxMatches { get; init; }
    public TimeSpan? Timeout { get; init; } = TimeSpan.FromSeconds(5);
}

/// <summary>
/// PUBLIC API: Search result with location information
/// </summary>
public sealed record SearchResult
{
    public int RowIndex { get; init; }
    public string ColumnName { get; init; } = string.Empty;
    public object? Value { get; init; }
    public string? MatchedText { get; init; }
    public int MatchStartIndex { get; init; }
    public int MatchLength { get; init; }

    public static SearchResult Create(int rowIndex, string columnName, object? value, string? matchedText = null, int startIndex = 0, int length = 0) =>
        new()
        {
            RowIndex = rowIndex,
            ColumnName = columnName,
            Value = value,
            MatchedText = matchedText,
            MatchStartIndex = startIndex,
            MatchLength = length
        };
}

/// <summary>
/// PUBLIC API: Filter result with statistics
/// </summary>
public sealed record FilterResult
{
    public int TotalRowsProcessed { get; init; }
    public int MatchingRows { get; init; }
    public int FilteredOutRows { get; init; }
    public TimeSpan ProcessingTime { get; init; }
    public IReadOnlyList<int> MatchingRowIndices { get; init; } = Array.Empty<int>();

    public static FilterResult Create(int total, int matching, TimeSpan processingTime, IReadOnlyList<int>? matchingIndices = null) =>
        new()
        {
            TotalRowsProcessed = total,
            MatchingRows = matching,
            FilteredOutRows = total - matching,
            ProcessingTime = processingTime,
            MatchingRowIndices = matchingIndices ?? Array.Empty<int>()
        };
}

/// <summary>
/// INTERNAL: Search & Filter engine implementation
/// PERFORMANCE: Optimized for large datasets with regex and complex filter support
/// </summary>
internal sealed class SearchFilterEngine : IDisposable
{
    private readonly Microsoft.Extensions.Logging.ILogger _logger;
    private bool _disposed;

    public SearchFilterEngine(Microsoft.Extensions.Logging.ILogger logger)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _logger.LogInformation("SEARCH_FILTER: Engine initialized");
    }

    /// <summary>
    /// ENTERPRISE: Execute advanced search with regex support
    /// PERFORMANCE: Optimized for large datasets with early termination
    /// </summary>
    public async Task<Result<IReadOnlyList<SearchResult>>> SearchAsync(
        IReadOnlyList<IReadOnlyDictionary<string, object?>> dataset,
        AdvancedSearchCriteria criteria)
    {
        try
        {
            _logger.LogInformation("SEARCH: Starting search with pattern '{Pattern}', regex: {UseRegex}, columns: [{Columns}]",
                criteria.SearchText, criteria.UseRegex, string.Join(", ", criteria.TargetColumns ?? new[] { "ALL" }));

            var results = new List<SearchResult>();
            var regex = criteria.UseRegex ? new Regex(criteria.SearchText,
                criteria.CaseSensitive ? RegexOptions.None : RegexOptions.IgnoreCase) : null;

            var columnsToSearch = criteria.TargetColumns ?? GetAllColumnNames(dataset);

            for (int rowIndex = 0; rowIndex < dataset.Count; rowIndex++)
            {
                var row = dataset[rowIndex];

                foreach (var columnName in columnsToSearch)
                {
                    if (!row.ContainsKey(columnName)) continue;

                    var cellValue = row[columnName];
                    var searchMatches = await SearchInValue(cellValue, criteria.SearchText, regex, criteria.CaseSensitive);

                    foreach (var match in searchMatches)
                    {
                        results.Add(SearchResult.Create(rowIndex, columnName, cellValue, match.Text, match.Start, match.Length));

                        if (criteria.MaxMatches.HasValue && results.Count >= criteria.MaxMatches.Value)
                        {
                            _logger.LogInformation("SEARCH: Reached maximum matches limit ({MaxMatches})", criteria.MaxMatches.Value);
                            return Result<IReadOnlyList<SearchResult>>.Success(results);
                        }
                    }
                }
            }

            _logger.LogInformation("SEARCH: Completed with {MatchCount} matches found", results.Count);
            return Result<IReadOnlyList<SearchResult>>.Success(results);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "SEARCH: Error during search operation");
            return Result<IReadOnlyList<SearchResult>>.Failure("Search operation failed", ex);
        }
    }

    /// <summary>
    /// ENTERPRISE: Apply complex filters with business logic combinations
    /// PERFORMANCE: Optimized filter evaluation with short-circuiting
    /// </summary>
    public async Task<Result<FilterResult>> ApplyFiltersAsync(
        IReadOnlyList<IReadOnlyDictionary<string, object?>> dataset,
        IReadOnlyList<FilterDefinition> filters)
    {
        try
        {
            _logger.LogInformation("FILTER: Applying {FilterCount} filters to {RowCount} rows", filters.Count, dataset.Count);

            var startTime = DateTime.UtcNow;
            var matchingIndices = new List<int>();

            for (int rowIndex = 0; rowIndex < dataset.Count; rowIndex++)
            {
                var row = dataset[rowIndex];
                bool rowMatches = await EvaluateFiltersForRow(row, filters);

                if (rowMatches)
                {
                    matchingIndices.Add(rowIndex);
                }
            }

            var processingTime = DateTime.UtcNow - startTime;
            var result = FilterResult.Create(dataset.Count, matchingIndices.Count, processingTime, matchingIndices);

            _logger.LogInformation("FILTER: Completed in {ProcessingTime}ms, {MatchingRows}/{TotalRows} rows match",
                processingTime.TotalMilliseconds, matchingIndices.Count, dataset.Count);

            return Result<FilterResult>.Success(result);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "FILTER: Error during filter operation");
            return Result<FilterResult>.Failure("Filter operation failed", ex);
        }
    }

    private async Task<bool> EvaluateFiltersForRow(IReadOnlyDictionary<string, object?> row, IReadOnlyList<FilterDefinition> filters)
    {
        if (!filters.Any()) return true;

        // Simple implementation for now - can be extended for complex logical operations
        bool result = true;
        FilterLogicOperator currentLogic = FilterLogicOperator.And;

        foreach (var filter in filters)
        {
            bool filterResult = await EvaluateSingleFilter(row, filter);

            if (currentLogic == FilterLogicOperator.And)
            {
                result = result && filterResult;
            }
            else
            {
                result = result || filterResult;
            }

            currentLogic = filter.LogicOperator;
        }

        return result;
    }

    private async Task<bool> EvaluateSingleFilter(IReadOnlyDictionary<string, object?> row, FilterDefinition filter)
    {
        if (string.IsNullOrEmpty(filter.ColumnName) || !row.ContainsKey(filter.ColumnName))
            return true;

        var cellValue = row[filter.ColumnName];

        return filter.Operator switch
        {
            FilterOperator.Equals => Equals(cellValue, filter.Value),
            FilterOperator.NotEquals => !Equals(cellValue, filter.Value),
            FilterOperator.Contains => cellValue?.ToString()?.Contains(filter.Value?.ToString() ?? "") == true,
            FilterOperator.NotContains => cellValue?.ToString()?.Contains(filter.Value?.ToString() ?? "") == false,
            FilterOperator.StartsWith => cellValue?.ToString()?.StartsWith(filter.Value?.ToString() ?? "") == true,
            FilterOperator.EndsWith => cellValue?.ToString()?.EndsWith(filter.Value?.ToString() ?? "") == true,
            FilterOperator.GreaterThan => CompareValues(cellValue, filter.Value) > 0,
            FilterOperator.LessThan => CompareValues(cellValue, filter.Value) < 0,
            FilterOperator.GreaterThanOrEqual => CompareValues(cellValue, filter.Value) >= 0,
            FilterOperator.LessThanOrEqual => CompareValues(cellValue, filter.Value) <= 0,
            FilterOperator.IsNull => cellValue == null,
            FilterOperator.IsNotNull => cellValue != null,
            FilterOperator.IsEmpty => string.IsNullOrEmpty(cellValue?.ToString()),
            FilterOperator.IsNotEmpty => !string.IsNullOrEmpty(cellValue?.ToString()),
            FilterOperator.Regex => EvaluateRegexFilter(cellValue, filter.Value?.ToString()),
            FilterOperator.Between => EvaluateBetweenFilter(cellValue, filter.Value, filter.SecondValue),
            _ => true
        };
    }

    private bool EvaluateRegexFilter(object? cellValue, string? pattern)
    {
        if (string.IsNullOrEmpty(pattern) || cellValue == null) return false;

        try
        {
            var regex = new Regex(pattern, RegexOptions.IgnoreCase);
            return regex.IsMatch(cellValue.ToString() ?? "");
        }
        catch (Exception ex)
        {
            _logger.LogWarning("FILTER: Invalid regex pattern '{Pattern}': {Error}", pattern, ex.Message);
            return false;
        }
    }

    private bool EvaluateBetweenFilter(object? cellValue, object? fromValue, object? toValue)
    {
        if (cellValue == null || fromValue == null || toValue == null) return false;

        return CompareValues(cellValue, fromValue) >= 0 && CompareValues(cellValue, toValue) <= 0;
    }

    private int CompareValues(object? value1, object? value2)
    {
        if (value1 == null && value2 == null) return 0;
        if (value1 == null) return -1;
        if (value2 == null) return 1;

        // Try numeric comparison first
        if (decimal.TryParse(value1.ToString(), out var num1) && decimal.TryParse(value2.ToString(), out var num2))
        {
            return num1.CompareTo(num2);
        }

        // Try date comparison
        if (DateTime.TryParse(value1.ToString(), out var date1) && DateTime.TryParse(value2.ToString(), out var date2))
        {
            return date1.CompareTo(date2);
        }

        // Fall back to string comparison
        return string.Compare(value1.ToString(), value2.ToString(), StringComparison.OrdinalIgnoreCase);
    }

    private async Task<IEnumerable<(string Text, int Start, int Length)>> SearchInValue(
        object? cellValue,
        string searchText,
        Regex? regex,
        bool caseSensitive)
    {
        if (cellValue == null || string.IsNullOrEmpty(searchText))
            return Enumerable.Empty<(string, int, int)>();

        var valueText = cellValue.ToString() ?? "";

        if (regex != null)
        {
            var matches = regex.Matches(valueText);
            return matches.Cast<Match>().Select(m => (m.Value, m.Index, m.Length));
        }
        else
        {
            var comparison = caseSensitive ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase;
            var index = valueText.IndexOf(searchText, comparison);

            if (index >= 0)
            {
                return new[] { (searchText, index, searchText.Length) };
            }
        }

        return Enumerable.Empty<(string, int, int)>();
    }

    private string[] GetAllColumnNames(IReadOnlyList<IReadOnlyDictionary<string, object?>> dataset)
    {
        if (!dataset.Any()) return Array.Empty<string>();

        return dataset.First().Keys.ToArray();
    }

    public void Dispose()
    {
        if (_disposed) return;

        _logger.LogInformation("SEARCH_FILTER: Engine disposed");
        _disposed = true;
    }
}

/// <summary>
/// INTERNAL: Result pattern for safe operations
/// </summary>
internal sealed record Result<T>
{
    public bool IsSuccess { get; init; }
    public bool IsFailure => !IsSuccess;
    public T? Value { get; init; }
    public string? Error { get; init; }
    public Exception? Exception { get; init; }

    private Result() { }

    public static Result<T> Success(T value) => new() { IsSuccess = true, Value = value };
    public static Result<T> Failure(string error, Exception? exception = null) =>
        new() { IsSuccess = false, Error = error, Exception = exception };
}